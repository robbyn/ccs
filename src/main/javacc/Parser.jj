options {
    STATIC = false;
    IGNORE_CASE = false;
}
PARSER_BEGIN(Parser)
package ccs.parser;
import ccs.compiler.Compiler;
import org.tastefuljava.classfile.CodeSegment;
import ccs.compiler.Type;
import ccs.compiler.Strings;

public class Parser extends Compiler {
    public void parse() throws ParseException {
        input();
    }
}
PARSER_END(Parser)

SKIP :
{
< " " | "\t" | "\r" | "\n" | "\r\n" >
| <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n") >
| <"/*"(~["/"])*  "*""/" >
}
TOKEN : { < VAR: "VAR" > }
TOKEN : { < AS: "AS" >}
TOKEN : { < START: "START" > | < STOP: "STOP" > | < OUTPUT: "OUTPUT" > } 
TOKEN : /* KEYWORDS */
{
    <INT: "INT"> | <BOOL:"BOOL"> | <FLOAT:"FLOAT"> | <CHAR:"CHAR">
    |<AND: "AND"> | <OR: "OR"> | <NOT: "NOT">
}

TOKEN :
{
  < EQUALS: "=" > | < COLON: ":" > | <LPAR: "(">|<RPAR: ")">
}
TOKEN:
{
  < PLUS : "+" >|< MINUS :"-" >|< MUL: "*" >|< DIV: "/" >|< MOD: "%" >|< COMM: ",">
  |<LT: "<">|<GT: ">">|<LE: "<=">|<GE: ">=">|<EQ: "==">|<NE: "<>">
  |<CAT: "&">
}
TOKEN:
{
    < VARIABLE: <LETTER>(<LETTER>|<DIGIT>)* >
    | < #LETTER: ["a"-"z", "A"-"Z", "_"] >
    | < #DIGIT: ["0"-"9"] >
}
TOKEN:
{
    < INT_VALUE: (<DIGIT>)+ >
    | < FLOAT_VALUE: <INT_VALUE> "." (<DIGIT>)* | "." (<DIGIT>)+ >
    | < CHAR_VALUE: "\'" (~["\'","\\"]|<ESCAPE>) "\'" >
    | < STRING_VALUE: "\"" (~["\"","\\"]|<ESCAPE>)* "\"" >
    | < #ESCAPE: "[" ~[] "]" >
}

void input(): {} { (declaration())*  body() }
void declaration(): {Type t;}
{
    (<VAR> varDeclaration() (<COMM> varDeclaration())* <AS> t=type())
    { declareAllVars(t); }
}
void varDeclaration():
    { Token n; CodeSegment seg = null; Type t = null; }
{
    ( n=<VARIABLE> (<EQUALS> { openSegment(); } t=literalValue() { seg = closeSegment(); })? )
    {
        if (seg == null) {
            addVar(n.image, n.beginLine, n.beginColumn);
        } else {
            addVar(n.image, n.beginLine, n.beginColumn, seg, t);
        }
    }
}
Type literalValue(): { Token t; Type result; }
{
    (
        t=<INT_VALUE> { literalInt(t.image); result = Type.INT; }
        | t=<FLOAT_VALUE> { literalInt(t.image); result = Type.FLOAT; }
        | t=<CHAR_VALUE> { literalChar(t.image); result = Type.CHAR; }
        | t=<STRING_VALUE> { literalString(t.image); result = Type.STRING; }
    )
    { return result; }
}
Type type(): {Type result;} {
    (
        <INT> { result = Type.INT; }
        | <FLOAT> { result = Type.FLOAT; }
        | <BOOL> { result = Type.BOOL; }
        | <CHAR> { result = Type.CHAR; }
    )
    { return result; }
}
void body(): {} { <START> (statement())* <STOP> }
void statement(): {} { assignment() | output() }
void assignment(): {} { <VARIABLE> <EQUALS> expression() }
void output(): { Type t; } { <OUTPUT> <COLON> t=expression() {output(t);} }
Type expression(): {Token op; Type t,t2;} {
    ( t=comparison() (op=logicalOp() {openSegment();} t2=comparison() { t=op2(op.image,t,t2,closeSegment()); })* )
    { return t; }
}
Token logicalOp(): {Token t;} {
    (t=<AND> | t=<OR>)
    { return t; }
}
Type comparison(): {Token op; Type t,t2;} {
    (
        t=simpleExpression()
        ( op=comparisonOp() {openSegment();} t2=simpleExpression() { t=op2(op.image,t,t2,closeSegment()); } )?
    )
    { return t; }
}
Token comparisonOp(): {Token t;} {
    ( t=<LT> | t=<GT> | t=<LE> | t=<GE> | t=<EQ> | t=<NE> )
    {return t;}
}
Type simpleExpression(): {Token op; Type t,t2;} {
    ( t=term() ( op=addOp() {openSegment();} t2=term() { t=op2(op.image,t,t2,closeSegment()); })* )
    { return t; }
}
Token addOp(): {Token t;} {
    ( t=<PLUS> | t=<MINUS> | t=<CAT> )
    { return t; }
}
Type term(): {Token op; Type t,t2;} {
    ( t=factor() ( op=mulOp() {openSegment();} t2=factor() { t=op2(op.image,t,t2,closeSegment()); } )* )
    { return t; }
}
Token mulOp(): {Token t;} {
    ( t=<MUL> | t=<DIV> | t=<MOD> )
    { return t; }
}
Type factor(): {boolean neg = false; Type t; Token n; } {
    (
        (<PLUS>|<MINUS> {neg=!neg;}) t=factor() { if (neg) neg(t); }
        | <LPAR> t=expression() <RPAR>
        | <NOT> t=expression()
        | n=<VARIABLE> { t = loadVar(n.image); }
        | t=literalValue()
    )
    { return t; }
}
